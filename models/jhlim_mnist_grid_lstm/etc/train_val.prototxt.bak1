# "2D Grid-LSTM example"
name: "2DGridLSTM_example"
### Training Set
layer {
  top: "data"
  top: "label"
  name: "data"
  type: "Data"
  data_param {
    source: "/path/to/mnist_train_lmdb"
    batch_size: 32
    backend: LMDB
    shuffle: true
  }
  include {
    phase: TRAIN
  }
  transform_param {
    mirror: true
    scale: 0.003921569 # 1/255
  }
}
### Validation Set
layer {
  top: "data"
  top: "label"
  name: "data"
  type: "Data"
  data_param {
    source: "/path/to/mnist_val_lmdb"
    batch_size: 32
    backend: LMDB
  }
  include {
    phase: TEST
  }
  transform_param {
    mirror: false
    scale: 0.003921569 # 1/255
  }
}

### 3D Grid LSTM start
layer { 
  bottom: "data"
  top:    "d0/d/h" 
  top:    "d0/d/c"
  # if peephole is false
  #top:    "d0/d/c_transformed"
  type: "Split" 
}
layer {
  bottom: "d0/d/h" 
  top:    "d0/d/h_transformed"
  type: "Convolution" 
  convolution_param {
    num_output: ?? # = num_output x 4 x 3
    kernel_size: 1
    stride: 1
}
## Make c_transformed if peephole is true
#layer { 
#  bottom: "d0/d/c"
#  top:    "d0/d/c_transformed"
#  type: "Convolution"
#  convolution_param {
#    num_output: ?? # = num_output x 3 x 3
#    kernel_size: 1
#    stride: 1
#  }
#  bias_term: false
#}
## Slice d0/h
# Slice d0/h along height dimension
layer {
  bottom: "d0/d/h"
  top:    "h1_d0/d/h"
  top:    "h2_d0/d/h"
  type: "Slice"
  slice_param {
    axis: 2
  }
}
# (Further) slice d0/h along width dimension
layer {
  bottom: "h1_d0/d/h"
  top:    "h1_w1_d0/d/h"
  top:    "h1_w2_d0/d/h"
  type: "Slice"
  slice_param {
    axis: 3
  }
}
layer {
  bottom: "h2_d0/d/h"
  top:    "h2_w1_d0/d/h"
  top:    "h2_w2_d0/d/h"
  type: "Slice"
  slice_param {
    axis: 3
  }
}
## Slice d0/h_transformed 
# Slice d0/h_transformed along height dimension
layer {
  bottom: "d0/d/h_transformed"
  top:    "h1_d0/d/h_transformed"
  top:    "h2_d0/d/h_transformed"
  type: "Slice"
  slice_param {
    axis: 2
  }
}
# (Further) slice d0/h_transformed along width dimension
layer {
  bottom: "h1_d0/d/h_transformed"
  top:    "h1_w1_d0/d/h_transformed"
  top:    "h1_w2_d0/d/h_transformed"
  type: "Slice"
  slice_param {
    axis: 3
  }
}
layer {
  bottom: "h2_d0/d/h_transformed"
  top:    "h2_w1_d0/d/h_transformed"
  top:    "h2_w2_d0/d/h_transformed"
  type: "Slice"
  slice_param {
    axis: 3
  }
}
## Slice d0/c
# Slice d0/c along height dimension
layer {
  bottom: "d0/d/c"
  top:    "h1_d0/d/c"
  top:    "h2_d0/d/c"
  type: "Slice"
  slice_param {
    axis: 2
  }
}
# (Further) slice d0/c along width dimension
layer {
  bottom: "h1_d0/d/c"
  top:    "h1_w1_d0/d/c"
  top:    "h1_w2_d0/d/c"
  type: "Slice"
  slice_param {
    axis: 3
  }
}
layer {
  bottom: "h2_d0/d/c"
  top:    "h2_w1_d0/d/c"
  top:    "h2_w2_d0/d/c"
  type: "Slice"
  slice_param {
    axis: 3
  }
}
## Initialize memory cells and hiddens in 3DGridLayer along height dimension and width dimension
input: "h0_w1_d1/h/c" # height increment direction
input: "h0_w1_d1/h/h" # c = mem cell, h = hidden state 

input: "h0_w2_d1/h/c" # height increment direction
input: "h0_w2_d1/h/h"  

input: "h1_w0_d1/w/c" # width increment direction
input: "h1_w0_d1/w/h"  

input: "h2_w0_d1/w/c" # width increment direction
input: "h2_w0_d1/w/h"  

## Propagate grid architecture 
# Basic naming convention:
#   "<position>/<direction>/<component>" where component is layer specific (e.g. c and h is for LSTM)
# first
layer {
  bottom: "h0_w1_d1/h/h"
  top: "h0_w1_d1/h/h_transformed"
  type: "InnerProduct"  
  inner_product_param {
    num_output: ?? # = numoutput x 4 x 3
  }
  bias_term: false
}
layer {
  bottom: "h1_w0_d1/w/h"
  top:    "h1_w0_d1/w/h_transformed" 
  type: "InnerProduct"
  inner_product_param {
    num_output: ?? # = numoutput x 4 x 3
  }
  bias_term: false
}
layer { # height increment direction
  bottom: "h0_w1_d1/h/h_transformed"
  bottom: "h1_w0_d1/w/h_transformed"
  bottom: "h1_w1_d0/d/h_transformed"
  top:    "h1_w1_d1/h/gate_input"  
  type: "Eltwise"
  eltwise_param {
    operation: SUM
  }
}
layer { # height increment direction 
  bottom: "h0_w1_d1/h/c" # height increment (memory) cell
  bottom: "h1_w1_d1/h/gate_input" 
  top:    "h1_w1_d1/h/c"
  top:    "h1_w1_d1/h/h"
  name:   "h1_w1_d1/h"
  type: "LSTMUnit" 
}
layer { # height increment direction
  bottom: "h0_w1_d1/h/c" # height increment (memory) cell
  bottom: "h0_w1_d1/h/h"
  bottom: "h1_w0_d1/w/h"
  bottom: "h1_w1_d0/d/h"
  top:    "h1_w1_d1/h/c"  
  top:    "h1_w1_d1/h/h"
  name:   "h1_w1_d1/h"
  type: "LSTM"
}
layer {
  bottom: "h1_w1_d1/h/c"
  bottom: "h1_w1_d1/h/h"
  bottom: "h2_w0_d1/w/h"
  bottom: "h2_w1_d0/d/h"
  top:    "h2_w1_d1/h/c"
  top:    "h2_w1_d1/h/h"
  name:   "h2_w1_d1/h"
  type: "3DGridLSTM"
}
# third
layer { # height increment direction
  bottom: "h0_w2_d1/h/c" 
  bottom: "h0_w2_d1/h/h"
  bottom: "h1_w1_d1/w/h"
  bottom: "h1_w2_d0/d/h"
  top:    "h1_w2_d1/h/c"
  top:    "h1_w2_d1/h/h"
  name:   "h1_w2_d1/h"
  type: "3DGridLSTM"
}
layer {
  bottom: "h1_w2_d1/h/c"
  bottom: "h1_w2_d1/h/h"
  bottom: "h2_w1_d1/w/h"
  bottom: "h2_w2_d0/d/h"
  top:    "h2_w2_d1/h/c"
  top:    "h2_w2_d1/h/h"
  name:   "h2_w2_d1/h"
  type: "3DGridLSTM"
}
# second
layer { # width increment direction
  bottom: "h0_w1_d1/h/h"
  bottom: "h1_w0_d1/w/c" # width increment (memory) cell
  bottom: "h1_w0_d1/w/h"
  bottom: "h1_w1_d0/d/h"
  top:    "h1_w1_d1/w/c"
  top:    "h1_w1_d1/w/h"
  name:   "h1_w1_d1/w"
  type: "3DGridLSTM"
}
layer {
  bottom: "h0_w2_d1/h/h"
  bottom: "h1_w1_d1/w/c" 
  bottom: "h1_w1_d1/w/h"
  bottom: "h1_w2_d0/d/h"
  top:    "h1_w2_d1/w/c"
  top:    "h1_w2_d1/w/h"
  name:   "h1_w2_d1/w"
  type: "3DGridLSTM"
}
# fourth
layer { # width increment direction
  bottom: "h1_w1_d1/h/h"
  bottom: "h2_w0_d1/w/c"
  bottom: "h2_w0_d1/w/h"
  bottom: "h2_w1_d0/d/h"
  top:    "h2_w1_d1/w/c"
  top:    "h2_w1_d1/w/h"
  name:   "h2_w1_d1/w"
  type: "3DGridLSTM"
}
layer {
  bottom: "h1_w2_d1/h/h"
  bottom: "h2_w1_d1/w/c"
  bottom: "h2_w1_d1/w/h"
  bottom: "h2_w2_d0/d/h"
  top:    "h2_w2_d1/w/c"
  top:    "h2_w2_d1/w/h"
  name:   "h2_w2_d1/w"
  type: "3DGridLSTM"
}
# fifth
layer { # depth increment direction
  bottom: "h0_w1_d1/h/h"  "h1_w1_d1/h/h"
  bottom: "h1_w0_d1/w/h"  "h1_w1_d1/w/h"
  bottom: "h1_w1_d0/d/c"  "h1_w1_d0/d/c" # depth increment (memory) cell
  bottom: "h1_w1_d0/d/h"  "h1_w1_d0/d/h"
  top:    "h1_w1_d1/d/c"  "h1_w1_d1/d/c"
  top:    "h1_w1_d1/d/h"  "h1_w1_d1/d/c"
  name:   "h1_w1_d1/d"    "h1_w1_d1/d/priority"
  type: "3DGridLSTM"
}
layer { # depth increment direction
  bottom: "h1_w1_d1/h/h"  "h2_w1_d1/h/h"
  bottom: "h2_w0_d1/w/h"  "h2_w1_d1/w/h"
  bottom: "h2_w1_d0/d/c"  "h2_w1_d0/d/c"
  bottom: "h2_w1_d0/d/h"  "h2_w1_d0/d/h"
  top:    "h2_w1_d1/d/c"  "h2_w1_d1/d/c"
  top:    "h2_w1_d1/d/h"  "h2_w1_d1/d/h"
  name:   "h2_w1_d1/d"    "h2_w1_d1/d/priority"
  type: "3DGridLSTM"
}
layer { # depth increment direction
  bottom: "h0_w2_d1/h/h"  "h1_w2_d1/h/h"
  bottom: "h1_w1_d1/w/h"  "h1_w2_d1/w/h"
  bottom: "h1_w2_d0/d/c"  "h1_w2_d0/d/c"
  bottom: "h1_w2_d0/d/h"  "h1_w2_d0/d/h"
  top:    "h1_w2_d1/d/c"  "h1_w2_d1/d/c"
  top:    "h1_w2_d1/d/h"  "h1_w2_d1/d/h"
  name:   "h1_w2_d1/d"    "h1_w2_d1/d/priority"
  type: "3DGridLSTM"
}
layer { # depth increment direction
  bottom: "h1_w2_d1/h/h"  "h2_w2_d1/h/h"
  bottom: "h2_w1_d1/w/h"  "h2_w2_d1/w/h"
  bottom: "h2_w2_d0/d/c"  "h2_w2_d0/d/c"
  bottom: "h2_w2_d0/d/h"  "h2_w2_d0/d/h"
  top:    "h2_w2_d1/d/c"  "h2_w2_d1/d/c"
  top:    "h2_w2_d1/d/h"  "h2_w2_d1/d/h"
  name:   "h2_w2_d1/d"    "h2_w2_d1/d/priority"
  type: "3DGridLSTM"
}
## Sum up!!
# hidden
layer {
  bottom: "h1_w1_d1/d/h"
  bottom: "h1_w2_d1/d/h"
  top:    "h1_d1/d/h"
  type: "Concat"
  conat_param {
    axis: 3
  }
}
layer {
  bottom: "h2_w1_d1/d/h"
  bottom: "h2_w2_d1/d/h"
  top: "h2_d1/d/h"
  type: "Concat"
  concat_param {
    axis: 3
  }
}
layer {
  bottom: "h1_d1/d/h"
  bottom: "h2_d1/d/h"
  top: "d1/d/h"
  type: "Concat"
  concat_param {
    axis: 2
  }
}
# memory cell
layer {
  bottom: "h1_w1_d1/d/c"
  bottom: "h1_w2_d1/d/c"
  top:    "h1_d1/d/c"
  type: "Concat"
  conat_param {
    axis: 3
  }
}
layer {
  bottom: "h2_w1_d1/d/c"
  bottom: "h2_w2_d1/d/c"
  top: "h2_d1/d/c"
  type: "Concat"
  concat_param {
    axis: 3
  }
}
layer {
  bottom: "h1_d1/d/c"
  bottom: "h2_d1/d/c"
  top: "d1/d/c"
  type: "Concat"
  concat_param {
    axis: 2
  }
}
# together
layer {
  bottom: "d1/d/c"
  bottom: "d1/d/h"
  top: "out"
  type: "Concat"
  concat_param {
    axis: 1
  }
}

